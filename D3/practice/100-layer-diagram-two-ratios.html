<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Layer diagram</title>

    <!--D3-->
    <script type="text/javascript" src="./d3.js"></script>

    <!--Tensorflow-->
    <script src="./tf.min.js"></script>

    <style type="text/css">
        /* No style rules here yet */
    </style>

</head>
<body>

<script type="text/javascript">

    "use strict";

    // FUNCTIONS =====================================================

    // Function to inject attributes a each unit
    function tagUnit(object, newKey, newValue){
        object[newKey]=newValue;
    }

    // Function to inject attributes each unit
    function tagUnits(arrayOfObjects, newKey, newValue){
        arrayOfObjects.forEach(
            function iterator ( value, index, collection ) {
                tagUnit(collection[index], newKey, newValue);
            }
        );
    }

    function splitToChunks(array, parts) {
        let result = [];
        for (let i = parts; i > 0; i--) {
            result.push(array.splice(0, Math.ceil(array.length / i)));
        }
        return result;
    }

    // PARAMETERS =====================================================

    // Dataset parameters
    let category1 = 1, // 500 (titanic)
        category2 = 100;  // 809 (titanic)


    // Visualization parameters
    let iconSize = 5,
        defaultIconColor = 'teal',
        canvasWidth = 600,
        canvasHeight = 600,
        padding = 50;



    // GENERATE DATA =====================================================

    // let dataset = [
    //     { key:'survived', value:[
    //         { key:'total', value:noOfSurvivors },
    //         { key:'male', value:noOfMaleSurvivors },
    //         { key:'female', value:noOfFemaleSurvivors },
    //     ]},
    //     { key:'dead', value:[
    //         { key:'total', value:noOfCasualties },
    //         { key:'male', value:noOfMaleCasualties },
    //         { key:'female', value:noOfFemaleCasualties },
    //     ]}
    // ];

    let datasetSummary = {
        'survived': {
            'total': category1,
            'male':null,
            'female':null
        },
        'dead':{
            'total': category2,
            'male':null,
            'female':null
        }
    };


    // Get the total number of units in the dataset

    let totalUnitCount = 0;

    for (let topCategory in datasetSummary) {
            totalUnitCount = totalUnitCount + datasetSummary[topCategory]['total'];
    }

    // Generate units
    // let a = tf.tensor1d([]);
    // a=a.concat(tf.tensor1d([1]), 0);
    // a=a.concat(tf.tensor1d([1]), 0);
    // a=a.concat(tf.tensor1d([12]), 0);
    // a=a.concat(tf.tensor1d([{'a':1}]), 0);
    //
    // a.print();

    let units = [];
    let i;
    for (i=0; i < totalUnitCount; i++){
        units.push({'id': i});
    }

    // Write category information to units
    tagUnits(units.slice(0, category1), 'status', 'survived');
    tagUnits(units.slice(category1, category1 + category2), 'status', 'deceased');

    // tagCount = noOfFemaleSurvivors;
    // for (let i = 0; i < units.length; i++){
    //     if (units[i]['status']==='survived'){
    //
    //         units[i]['gender']='male';
    //         tagCount--
    //
    //     }
    // }

    // Make a list of categories in the 'unit' variable
    let categories = [];
    for (let arrayKey in units){
        for (let dictKey in units[arrayKey]){

            let categoryName = dictKey;

            if (!categories.includes(categoryName)){
                categories.push(categoryName);
            }
        }
    }

    // Ensure that 'id' is not a category
    for (let i=0; i < categories.length; i++){
        if (categories[i] = 'id'){
            categories.splice(i, 1)
        }
    }



    // VISUALIZE THE DATA ==================================================

    // Calculate edge length
    let edgeSizeAbsolute = Math.sqrt(totalUnitCount),
        edgeSizeCeiled = Math.ceil(Math.sqrt(totalUnitCount));


    // Create scales
    let scaleSquareX = d3.scaleBand()
        .domain(d3.range(edgeSizeCeiled))
        .rangeRound([padding, canvasWidth-padding])
        .paddingInner(0.05);

    let scaleSquareY = d3.scaleBand()
        .domain(d3.range(edgeSizeCeiled))
        .rangeRound([canvasHeight-padding, padding])  // reversed scale
        .paddingInner(0.05);

    // Create coordinates array
    let coordinates = [];
    let column;
    let row;
    for (row = 0; row < edgeSizeCeiled; row++) {

        for (column = 0; column < edgeSizeCeiled; column++){
            coordinates.push({'x': scaleSquareX(column), 'y': scaleSquareY(row)});
        }
    }




    // Create SVG element
    let svg = d3.select('body')
            .append('svg')
            .attr('width', canvasWidth)
            .attr('height', canvasHeight);

    // Create circles
    let circles = svg.selectAll('circle')
                .data(units)
                .enter()
                .append('circle')
                .attr('cx', function (d, i) {
                    return coordinates[i]['x']
                })
                .attr('cy', function (d, i) {
                    return coordinates[i]['y']
                })
                .attr('r', iconSize)
                .attr('fill', defaultIconColor);

    // Bind categories to units
    for(let i=0; i < categories.length; i++){
        circles.attr('class', function (d) {
            let eachCategory = categories[i];
            return d[eachCategory];
        })
    }


    // for (let eachCategory in categories){
    //     circles.attr('class', function (d) {
    //         return d[eachCategory];
    //     });
    // }

    // circles
    //     .attr('class', function (d) {  // assign categories to each unit
    //         // console.log(JSON.stringify(d));
    //         // console.log(JSON.stringify(d));
    //         // console.log(JSON.stringify(d.keys()));




        // });

    // circles
    //     .attr('class', function (d) {  // assign gender
    //         return d['gender'];
    //     });

    // Color circles based on category
    d3.selectAll('.deceased')
        .attr('fill', 'red');

    d3.selectAll('.survived')
        .attr('fill', 'blue');


        // .attr('fill', function (d) {
        //     this.classed('female', function () { return 'red' })
        // });





    // Separate circles



    //Create labels

    //Create background

</script>



<!-- Generator: Adobe Illustrator 21.1.0, SVG Export Plug-In  -->
<svg
	 x="0px" y="0px" width="500px" height="600.3px" viewBox="0 0 2045.7 1767.3"
	 style="enable-background:new 0 0 2045.7 1767.3;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#F2F2F2;}
    .st1{fill:#B3B3B3;}
</style>
<defs>
</defs>
<g>
	<path class="st0" d="M25.5,1766.8c-13.8,0-25-11.1-25-24.7V25.2c0-13.6,11.2-24.7,25-24.7h1994.6c13.8,0,25,11.1,25,24.7v1557.9
		c0,13.6-11.2,24.7-25,24.7h-1495c-14.4,0-26,11.5-26,25.7v108.5c0,13.6-11.2,24.7-25,24.7H25.5z"/>
	<g>
		<path class="st1" d="M2020.1,1c13.5,0,24.5,10.9,24.5,24.2v1557.9c0,13.4-11,24.2-24.5,24.2H525.1c-14.6,0-26.5,11.8-26.5,26.2
			v108.5c0,13.4-11,24.2-24.5,24.2H25.5c-13.5,0-24.5-10.9-24.5-24.2v-133.7v-82V25.2C1,11.9,12,1,25.5,1H2020.1 M2020.1,0H25.5
			C11.4,0,0,11.3,0,25.2v1501.1v82v133.7c0,13.9,11.4,25.2,25.5,25.2H474c14.1,0,25.5-11.3,25.5-25.2v-108.5
			c0-13.9,11.4-25.2,25.5-25.2h1495.1c14.1,0,25.5-11.3,25.5-25.2V25.2C2045.7,11.3,2034.2,0,2020.1,0L2020.1,0z"/>
	</g>
</g>
</svg>



</body>
</html>




